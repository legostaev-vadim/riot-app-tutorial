<h3 id="create-component-userlist">Создание компонента UserList</h3>

Из папки **views**  удалите файл **Hello.tag**, поскольку компонент **Hello** нам больше не нужен. Удалите и его подключение из файлов **App.js** и **index.html**. Вот так теперь они должны у вас выглядеть:

**App.js**

```js
// подключаем Riot.js
import riot from 'riot'
```

**index.html**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Riot Application</title>
</head>
<body>
  <script src="build.js"></script>
</body>
</html>
```

В папке **views** создайте файл **UserList.tag**

```html
<r-list>

  <div class="list">
    
  </div>

</r-list>
```

Наш компонент пока содержит только шаблон, в виде пустого списка с классом **list**. Стили и логику мы добавим позже. Теперь давайте обратимся к списку пользователей из модели, которую мы создали ранее, чтобы динамически пройти по всем данным.

Добавьте в компонент **UserList** ссылки на пользователей:

```html
<r-list>

  <div class="list">

    <!-- добавляем ссылки на пользователей -->
    <a href="#!/edit/{ id }" class="list__item" each={ list } key={ id }>{ firstName } { lastName }</a>

  </div>

</r-list>
```

В ссылке имеется атрибут **each**, который отвечает за реализацию циклов в **Riot.js**. Он получает свойство **list** объекта компонента, которое, впоследствии, будет ссылаться на одноимённое свойство экземпляра объекта класса **User**, и представляет из себя массив объектов получаемых от сервера. Каждый объект в этом массиве содержит свойства: **id**, **firstName** и **lastName**. В приведённом выше примере, мы просто выводим содержимое этих свойст в ссылку для каждого пользователя.

> Выражения в **Riot.js** заключаются в одинарные фигурные скобки и могут распологаться как в атрибутах тегов, так и представлять их содержимое находясь между ними. Кавычки в атрибутах не являются обязательными.

Вот как выглядит [JSON](https://ru.wikipedia.org/wiki/JSON)-файл получаемый с сервера:

```js
{
  "data": [
    {
      "id": 1,
      "firstName": "Peter",
      "lastName": "Mackenzie"
    },
    {
      "id": 2,
      "firstName": "Cindy",
      "lastName": "Zhang"
    },
    {
      "id": 3,
      "firstName": "Ted",
      "lastName": "Smith"
    },
    {
      "id": 4,
      "firstName": "Susan",
      "lastName": "Fernbrook"
    },
    {
      "id": 5,
      "firstName": "Emily",
      "lastName": "Kim"
    },
    {
      "id": 6,
      "firstName": "Peter",
      "lastName": "Zhang"
    },
    {
      "id": 7,
      "firstName": "Cindy",
      "lastName": "Smith"
    },
    {
      "id": 8,
      "firstName": "Ted",
      "lastName": "Fernbrook"
    },
    {
      "id": 9,
      "firstName": "Susan",
      "lastName": "Kim"
    },
    {
      "id": 10,
      "firstName": "Emily",
      "lastName": "Mackenzie"
    }
  ],
  "offset": 0,
  "limit": 10,
  "total": 25
}
```

В объекте нашей модели данных класса **User**, мы определили свойство **list**, которое является массивом и будет хранить содержимое свойства **data**, возвращаемого с сервера файла **JSON**. Последние три свойства в этом файле: **offset**, **limit** и **total** используются исключительно для уточнения запросов. Мы воспользуемся свойством **limit** позже, для указания количества выводимых пользователей. По умолчанию оно равно 10.

Добавим немного стилей в наш компонент. Стили в компоненте размещаются между стандартными тегами **style**:

```html
<r-list>

  <div class="list">

    <!-- добавляем ссылки на пользователей -->
    <a href="#!/edit/{ id }" class="list__item" each={ list } key={ id }>{ firstName } { lastName }</a>

  </div>

  <!--  добавляем стили  -->
  <style>
    .list {
      list-style: none;
      margin: 0 0 10px;
      padding: 0;
    }
    .list__item {
      background: #fafafa;
      border: 1px solid #ddd;
      color: #333;
      display: block;
      margin: 0 0 1px;
      padding: 8px 15px;
      text-decoration: none;
    }
    .list__item:hover {
      text-decoration: underline;
    }
  </style>

</r-list>
```

> Файл компонента представляет из себя обычный **HTML**, но с некоторыми усовершенствованиями, засчет возможностей **Riot.js**.

Последнее, что нам осталось сделать, это определить логику нашего компонента. Её можно разместить как между тегами **script**, так и просто в теле компонента. Мы будем использовать первый вариант.

Итак, нам нужно получить список пользователей с сервера и вывести их в нашем компоненте. Т.е. нам нужно вызвать метод **getUsers** экземплара класса **User**. Этот метод заполнит массив **list** данного класса полученными данными от сервера, а уже потом, мы сможем на него сослаться из нашего компонента и прогнать в цикле.

Для подобных целей, **Riot.js** предоставляет **примеси** и **наблюдателя**. Наблюдатель позволяет отслеживать события и выполнять соответствующие действия при их наступлении, а примеси расширяют функциональность нашего компонента, добавляя в него возможность эти события ловить и правильно на нах реагировать.

Давайте сделаем нашу модель данных наблюдаемой. Откройте файл **User.js** и в конструктор класса **User** добавьте параметр **riot**, через который мы будем ссылаться на библиотеку **Riot.js**, а в конце этого конструктора добавьте команду подключения наблюдателя:

```js
riot.observable(this)
```
Эта команда делает **наблюдаемым**, каждый возвращаемый экземпляр объекта класса **User**:

```js
constructor(riot) {
  this.list = []
  this.current = {}
  // делаем объект модели данных наблюдаемым
  riot.observable(this)
}
```

Теперь наш модуль хранения состояния выглядит так:

```js
export default class User {

  constructor(riot) {
    this.list = []
    this.current = {}
    // делаем объект модели данных наблюдаемым
    riot.observable(this)
  }

  // получаем список пользователей с сервера
  getUsers() {
    fetch('https://rem-rest-api.herokuapp.com/api/users', {
      method: 'GET',
      credentials: 'include'
    })
      .then(response => response.json())
      .then(result => {
        this.list = result.data
      })
  }
  
}
```

Наш объект модели данных теперь сможет запускать события, но в этом не будет никакого смысла, поскольку обработчики этих событий должны распологаться в компонентах, а они, попросту пока не могут контактировать с нашим наблюдателем. И для этого, в **Riot.js** предусмотрены **примеси**, которые позволяют расширить функциональность наблюдателя нашей модели данных на любые компонеты.

Откройте главный файл приложения **App.js**. Давайте создадим примесь **user**, которая будет ссылаться на экземпляр наблюдаемой модели данных класса **User**:

```js
// подключаем Riot.js
import riot from 'riot'

// подключаем модель данных User
import User from './models/User'

// создаём общую примесь user и передаём в конструктор модели данных User
// ссылку на библиотеку Riot.js, в виде аргумента riot
riot.mixin({ user: new User(riot) })
```

> Обратите внимание, что во время создания примеси **user**, мы передали в наш класс **ссылку** на библиотеку **Riot.js**, через аргумент **riot** класса **User**, которая будет доступна через одноимённый параметр данного класса. Также заметьте, что перед этим, мы подключили **модель данных** в приложение.

Осталось научить наши компоненты реагировать на события, которые будет генерировать наша модель данных, после успешного получения данных от сервера. Но прежде, давайте на минуту вернёмся в модуль нашей модели данных и научим нашу модель запускать эти самые события, после успешного ответа сервера.

Откройте файл **User.js** и в функции **getUsers**, в конце последнего **.then**, добавьте команду:

```js
this.trigger('updated')
```

Она будет следовать сразу, после присвоения данных ответа сервера свойству **list**, нашей модели данных класса **User**:

```js
.then(result => {
  // присваиваем результат ответа сервера свойству list модели данных
  this.list = result.data
  // запускаем событие updated, после успешного получения данных от сервера
  this.trigger('updated')
})
```

Полный код модуля хранения состояния должен выглядеть так:

```js
export default class User {

  constructor(riot) {
    this.list = []
    this.current = {}
    // делаем объект модели данных наблюдаемым
    riot.observable(this)
  }

  // получаем список пользователей с сервера
  getUsers() {
    fetch('https://rem-rest-api.herokuapp.com/api/users', {
      method: 'GET',
      credentials: 'include'
    })
      .then(response => response.json())
      .then(result => {
        // присваиваем результат ответа сервера свойству list модели данных
        this.list = result.data
        // запускаем событие updated, после успешного получения данных от сервера
        this.trigger('updated')
      })
  }
  
}
```

Закончим с компонентом **UserList**. Откройте файл **UserList.tag**, добавьте в конце тела компонента теги **script**, и введите следующий код:

```html
<script>
  
  // запускаем метод getUsers, нашей модели данных
  this.user.getUsers()
  
</script>
```

Поскольку мы расширили экземпляр модели данных класса **User** для любых компонентов с помощью примеси **user**, мы можем ссылаться на этот экземпляр данных, через одноимённое свойство самого **объекта компонента**, на которое указывает ключевое слово **this**.

Данный код будет выполнен до монтирования тега на страницу. Он запускает метод **getUsers** нашей модели данных, который, внутри себя, запускает **fetch**, который выполняется асинхронно, и после загрузки данных с сервера, вызывает событие **updated**.

Теперь нам нужно отловить это событие модели данных в нашем компоненте и запустить событие **update** самого компонента:

```html
<script>
  
  // запускаем метод getUsers, нашей модели данных
  this.user.getUsers()

  // запускаем событие обновления компонента (this.update)
  // при получении события updated от модели данных
  this.user.one('updated', this.update)

</script>
```

В котором, в свою очередь, мы присваиваем свойству **list** объекта компонента значение, одноимённого свойства **list** нашей модели данных:

```html
<script>
  
  // запускаем метод getUsers, нашей модели данных
  this.user.getUsers()

  // запускаем событие обновления компонента (this.update)
  // при получении события updated от модели данных
  this.user.one('updated', this.update)

  // присваиваем свойству list нашего компонента значение
  // полученное моделью данных при запуске её метода getUsers()
  this.on('update', () => this.list = this.user.list)

</script>
```

после чего, компонет обновляется и полученные данные отображаются на странице.

Итоговый код компонента **UserList**:

```html
<r-list>

  <div class="list">

    <!-- добавляем ссылки на пользователей -->
    <a href="#!/edit/{ id }" class="list__item" each={ list } key={ id }>{ firstName } { lastName }</a>

  </div>

  <!--  добавляем стили  -->
  <style>
    .list {
      list-style: none;
      margin: 0 0 10px;
      padding: 0;
    }
    .list__item {
      background: #fafafa;
      border: 1px solid #ddd;
      color: #333;
      display: block;
      margin: 0 0 1px;
      padding: 8px 15px;
      text-decoration: none;
    }
    .list__item:hover {
      text-decoration: underline;
    }
  </style>

  <!--  добавляем логику  -->
  <script>
  
    // запускаем метод getUsers, нашей модели данных
    this.user.getUsers()

    // запускаем событие обновления компонента (this.update)
    // при получении события updated от модели данных
    this.user.one('updated', this.update)

    // присваиваем свойству list нашего компонента значение
    // полученное моделью данных при запуске её метода getUsers()
    this.on('update', () => this.list = this.user.list)

  </script>

</r-list>
```

Подключим компонент к приложению и примонтируем его в файле **App.js**:

```js
// подключаем Riot.js
import riot from 'riot'

// подключаем модель данных User
import User from './models/User'

// подключаем компонент UserList
import './views/UserList.tag'

// создаём общую примесь user и передаём в конструктор модели данных User
// ссылку на библиотеку Riot.js, в виде аргумента riot
riot.mixin({ user: new User(riot) })

// монтируем компонент UserList
riot.mount('r-list')
```

а затем, подключим и к странице в файле **index.html**:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Riot Application</title>
</head>
<body>

  <!-- подключаем компонент UserList к странице -->
  <r-list />

  <script src="dist/build.js"></script>
</body>
</html>
```

Если мы теперь запустим из терминала команду:

```
npm run dev
```

то, откроется страница браузера со списком из 10 пользователей:

```
Peter Mackenzie
Cindy Zhang
Ted Smith
Susan Fernbrook
Emily Kim
Peter Zhang
Cindy Smith
Ted Fernbrook
Susan Kim
Emily Mackenzie
```

Мы увеличим лимит пользователей позже, когда будем реализовывать операции [CRUD](https://ru.wikipedia.org/wiki/CRUD) в другом компоненте, который мы тоже вскоре создадим.
